(*
	Usage:
		use regex : script "regex"

	Tried both sed and ruby.  Let's use ruby for more flexibility and familiarity.
	WARNING: Do not use unicode characters, it does not work with the ruby commandline!

	@Build:
		make compile-lib SOURCE=core/regex

	@Last Modified: 2023-07-24 13:23:19
*)

use framework "Foundation"
use scripting additions

use std : script "std"

use textUtil : script "string"
use listUtil : script "list"

use loggerFactory : script "logger-factory"

use spotScript : script "spot-test"

use testLib : script "test"

property logger : missing value

if {"Script Editor", "Script Debugger"} contains the name of current application then spotCheck()

on spotCheck()
	loggerFactory's injectBasic(me)
	logger's start()

	set cases to listUtil's splitByLine("
		Unit Test
		Quickie
		Case Insensitive Match
	")

	set spotClass to spotScript's new()
	set spot to spotClass's new(me, cases)
	set {caseIndex, caseDesc} to spot's start()
	if caseIndex is 0 then
		logger's finish()
		return
	end if

	if caseIndex is 1 then
		unitTest()

	else if caseIndex is 2 then
		log stringByReplacingMatchesInString(unic's OMZ_ARROW & "  [a-zA-Z-]+\\sgit:\\([a-zA-Z0-9/-]+\\)(?: " & unic's OMZ_GIT_X & ")?\\s", unic's OMZ_ARROW & "  mobile-gateway git:(feature/MT-3644-Mobile-Gateway-create-service-adapter) " & unic's OMZ_GIT_X & " docker network", "")

		log stringByReplacingMatchesInString("hello", "hello world", "")
		log firstMatchInString("\\w+", "hello world")
		log matchesInString("\\w+$", "hello world ")
		log numberOfMatchesInString("\\w+", "hello world -")

	else if caseIndex is 3 then
		log firstMatchInStringNoCase("abc", "the world of ABC is ok.")
		log firstMatchInString("abc", "the world of ABC is ok.")
		log firstMatchInStringNoCase("abc", "the world of abc is ok.")
		log firstMatchInString("abc", "the world of abc is ok.")
	end if

	spot's finish()
	logger's finish()
end spotCheck

on numberOfMatchesInString(pattern as text, searchString as text)
	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)
	return (nsregex's numberOfMatchesInString:searchString options:0 range:{location:0, |length|:(count searchString)}) as integer
end numberOfMatchesInString


on matchesInString(pattern as text, searchString as text)
	set anNSString to current application's NSString's stringWithString:searchString
	set stringLength to anNSString's |length|()
	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)
	set match to nsregex's firstMatchInString:anNSString options:0 range:{0, stringLength}
	if match is not missing value then return true

	false
end matchesInString


on firstMatchInString(pattern, searchString)
	if searchString is missing value or pattern is missing value then return missing value

	set anNSString to current application's NSString's stringWithString:searchString
	set stringLength to anNSString's |length|()
	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)

	set match to nsregex's firstMatchInString:anNSString options:0 range:{0, stringLength}

	if match is not missing value then
		set matchRange to match's numberOfRanges()
		--> 1, so exists only one range, with index=0
		set matchRange to match's rangeAtIndex:0
	else
		return missing value
	end if

	text ((matchRange's location) + 1) thru ((matchRange's location) + (matchRange's |length|)) of searchString
end firstMatchInString


on firstMatchInStringNoCase(pattern, searchString)
	if searchString is missing value or pattern is missing value then return missing value

	ignoring case
		set anNSString to current application's NSString's stringWithString:searchString
		set stringLength to anNSString's |length|()
		set caseInsensitiveOption to current application's NSRegularExpressionCaseInsensitive
		set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:caseInsensitiveOption |error|:(missing value)

		set match to nsregex's firstMatchInString:anNSString options:0 range:{0, stringLength}
		if match is missing value then return missing value

		set matchRange to match's numberOfRanges()
		set matchRange to match's rangeAtIndex:0
		text ((matchRange's location) + 1) thru ((matchRange's location) + (matchRange's |length|)) of searchString
	end ignoring
end firstMatchInStringNoCase


(* To test, generated by GPT. *)
on lastMatchInString(pattern, searchString)
	if searchString is missing value or pattern is missing value then return missing value

	set anNSString to current application's NSString's stringWithString:searchString
	set stringLength to anNSString's |length|()
	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)

	set matches to nsregex's matchesInString:anNSString options:0 range:{0, stringLength}

	if (matches's |count|()) > 0 then
		set lastMatch to (matches's lastObject())'s range()
		return text ((lastMatch's location) + 1) thru ((lastMatch's location) + (lastMatch's |length|)) of searchString
	end if

	missing value
end lastMatchInString


on stringByReplacingMatchesInString(pattern, searchString, replacement)
	set searchNSString to current application's NSString's stringWithString:searchString
	set replaceNSString to current application's NSString's stringWithString:replacement
	set stringLength to searchNSString's |length|()
	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)
	(nsregex's stringByReplacingMatchesInString:searchNSString options:0 range:{0, stringLength} withTemplate:replaceNSString) as text
end stringByReplacingMatchesInString


(* @returns list {offset, length} *)
on rangeOfFirstMatchInString(pattern, searchString)
	if searchString is missing value then return missing value

	set nsregex to current application's NSRegularExpression's regularExpressionWithPattern:pattern options:0 |error|:(missing value)
	set matchRange to (nsregex's rangeOfFirstMatchInString:searchString options:0 range:{location:0, |length|:(count searchString)})
	{(matchRange's location) + 1, matchRange's |length|}
end rangeOfFirstMatchInString


-- TODO: allMatchesInString


-- = Recommended Above = -----

(* replace all for initial implementation. *)
on replace(source, pattern, replacement)
	set escapedPattern to escapePattern(pattern)
	set escapedSource to escapeSource(source)
	(do shell script "ruby -e \"p '" & escapedSource & "'.gsub(/" & pattern & "/, '" & replacement & "')\" | sed 's/\"//g'")
end replace


(* Shell implementation is slower the the Objective-C equivalent. *)
on matched(source, pattern)
	matchesInString(pattern, source)
end matched


on matches(pattern, source)
	matched(source, pattern)
end matches


on findFirst(source, pattern)
	set escapedPattern to escapePattern(pattern)
	set escapedSource to escapeSource(source)

	do shell script "ruby -e \"p '" & escapedSource & "'[/" & escapedPattern & "/]\" | sed 's/\"//g'"
end findFirst


-- Private Codes below =======================================================
on escapeSource(source)
	textUtil's replace(source, "'", "\\'")
end escapeSource


on escapePattern(pattern)
	return pattern
end escapePattern

(*
	Handler grouped by hundredths.
	Put the case you are debugging at the top, and move to correct place once verified.
*)
on unitTest()
	set test to testLib's new()
	set ut to test's new()
	tell ut
		newMethod("lastMatchInString")
		assertMissingValue(my lastMatchInString("\\w", missing value), "String is missing value")
		assertMissingValue(my lastMatchInString("\\d", "abc"), "Not Found")
		assertEqual("2", my lastMatchInString("\\d", "1 for 2"), "Multi match")
		assertEquals("1", my lastMatchInString("\\d", "one hundred 1"), "Single match")

		newMethod("findFirst")
		assertEqual("https://awesome.zoom.us/j/123456789", my findFirst("B + S Daily Standup at https://awesome.zoom.us/j/123456789. Starts on September 15, 2020 at 8:00:00 AM Philippine Standard Time and ends at 8:15:00 AM Philippine Standard Time.", "https:\\/\\/\\w+\\.\\w+\\.\\w+\\/j\\/\\d+(?:\\?pwd=\\w+)?"), "Happy: Found")

		newMethod("matched")
		assertTrue(my matched("amazing", "maz"), "Found")
		assertFalse(my matched("amazing", "Amaz"), "Not Found")
		assertTrue(my matched("amazing", "^amaz"), "Starting with")
		assertFalse(my matched("amazing", "^maz"), "Not starting with")
		assertTrue(my matched("amazing", "zing$"), "Ending with")
		assertFalse(my matched("amazing", "zin$"), "Not ending with")
		assertTrue(my matched("a maz ing", "\\bmaz\\b"), "Whole word")
		assertFalse(my matched("amazing", "\\bmaz\\b"), "Not whole word")

		newMethod("replace")
		assertEqual("These number(12) and number(354)", my replace("These 12 and 354", "(\\d+)", "number(\\1)"), "Replace a group")
		assertEqual("riojenhbkcm@mailinator.com", my replace("Email : riojenhbkcm@mailinator.com", "Email : (\\w+@mailinator.com)", "\\1"), "Extract info")
		assertEqual("Don't", my replace("Can't", "Ca", "Do"), "With a single quote")
		assertEqual("Can't set window id 3864 to {1146 and one third, 719.0}.", my replace("Can't set window id 3864 to {1146.66666666, 719.0}.", "\\.6{3,}7?", " and one third"), "Number with decimal")

		newMethod("rangeOfFirstMatchInString")
		assertMissingValue(my rangeOfFirstMatchInString("\\w", missing value), "String is missing value")
		assertEquals({16, 5}, my rangeOfFirstMatchInString("\\d+", "Hello prisoner 14867"), "Happy Case")

		done()
	end tell
end unitTest
